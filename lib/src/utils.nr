use crate::{MAX_EMAIL_HEADER_LENGTH, MAX_EMAIL_ADDRESS_LENGTH, MAX_EMAIL_FIELD_LENGTH, MSG_HASH_LENGTH};
use dep::string_search::{StringBody, SubString, StringBody1024, SubString32, SubString64, SubString128};
use dep::zkemail::{headers::email_address::constrain_header_field_detect_last_angle_bracket, Sequence};

global FROM_FIELD_LENGTH: u32 = 4;
global TO_FIELD_LENGTH: u32 = 2;

/**
 * Check "from" field in the email header
 *
 * @param header - the entire email header
 * @param padded_from - the sender email address
 * @param from_seq - the from field sequence in header
 * @param email_seq - the email address sequence in header
 */
pub fn check_from_field(
    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,
    padded_from: [u8; MAX_EMAIL_ADDRESS_LENGTH],
    from_seq: Sequence,
    email_seq: Sequence
) {
    let from = comptime {
        "from".as_bytes()
    };

    // check field is uninterrupted and matches the expected field name
    let last_angle_bracket = constrain_header_field_detect_last_angle_bracket::<
        MAX_EMAIL_HEADER_LENGTH, MAX_EMAIL_FIELD_LENGTH, FROM_FIELD_LENGTH>(header, from_seq, from);
    
    // check start/end indexes of email
    if last_angle_bracket != 0 {
        assert(
            email_seq.index == last_angle_bracket + 1, "Email must start immediately after '<'"
        );
        assert(
            email_seq.end_index() == from_seq.end_index() - 1, "Email must end immediately before '>'"
        );
    } else {
        assert(
            email_seq.index == from_seq.index + FROM_FIELD_LENGTH + 1, "Email must start immediately after ':'"
        );
        assert(
            email_seq.end_index() == from_seq.end_index(), "Email must end in the same index as 'from' field"
        );
    }

    // check email address
    for i in 0..MAX_EMAIL_ADDRESS_LENGTH {
        let index = email_seq.index + i;
        if index < email_seq.end_index() {
            let letter = header.get_unchecked(index);
            assert(
                letter == padded_from[i], "Email address is different"
            );
        }
    }
}

 /**
 * Check "to" field in the email header
 *
 * @param header - the entire email header
 * @param padded_to - the recipient email address
 * @param to_seq - the to field sequence in header
 * @param email_seq - the email address sequence in header
 */
pub fn check_to_field(
    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,
    padded_to: [u8; MAX_EMAIL_ADDRESS_LENGTH],
    to_seq: Sequence,
    email_seq: Sequence
) {
    let to = comptime {
        "to".as_bytes()
    };

    // check field is uninterrupted and matches the expected field name
    let last_angle_bracket = constrain_header_field_detect_last_angle_bracket::<
        MAX_EMAIL_HEADER_LENGTH, MAX_EMAIL_FIELD_LENGTH, TO_FIELD_LENGTH>(header, to_seq, to);
    
    // check start/end indexes of email
    if last_angle_bracket != 0 {
        assert(
            email_seq.index == last_angle_bracket + 1, "Email must start immediately after '<'"
        );
        assert(
            email_seq.end_index() == to_seq.end_index() - 1, "Email must end immediately before '>'"
        );
    } else {
        assert(
            email_seq.index == to_seq.index + TO_FIELD_LENGTH + 1, "Email must start immediately after ':'"
        );
        assert(
            email_seq.end_index() == to_seq.end_index(), "Email must end in the same index as 'from' field"
        );
    }

    // check email address
    for i in 0..MAX_EMAIL_ADDRESS_LENGTH {
        let index = email_seq.index + i;
        if index < email_seq.end_index() {
            let letter = header.get_unchecked(index);
            assert(
                letter == padded_to[i], "Email address is different"
            );
        }
    }
}

/**
 * Find "subject" field in the email header
 *
 * @param header - the entire email header to search through
 * @param subject - the subject of email address
 * @returns (true/false if found, index of start in the header)
 */
pub fn find_subject_in_header(
    header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH>,
    subject: [u8; MSG_HASH_LENGTH]
) -> (bool, u32) {
    // init the search params
    let needle_text_init: [u8; 8] = "subject:".as_bytes();
    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());
    let needle_end: SubString64 = SubString::new(subject, subject.len());
    let needle = needle_start.concat_into(needle_end);

    // init the search domain
    let haystack: StringBody1024 = StringBody::new(header.storage, header.len);

    // find the index of the position
    haystack.substring_match(needle)
}


#[test]
fn test_check_to_field() {
    let relayer = "ad@oxor.io".as_bytes();
    let mut padded_relayer: [u8; MAX_EMAIL_ADDRESS_LENGTH] = [0; MAX_EMAIL_ADDRESS_LENGTH];
    for i in 0..relayer.len() {
        padded_relayer[i] = relayer[i];
    }
    for i in relayer.len()..MAX_EMAIL_ADDRESS_LENGTH {
        padded_relayer[i] = 0;
    }

    let header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH> = BoundedVec {
        storage: [116, 111, 58, 97, 100, 64, 111, 120, 111, 114, 46, 105, 111, 13, 10, 102, 114, 111, 109, 58, 115, 119, 111, 111, 110, 115, 46, 48, 48, 114, 117, 98, 98, 105, 110, 103, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 119, 70, 50, 115, 90, 68, 120, 52, 109, 99, 75, 54, 65, 115, 74, 88, 84, 74, 77, 82, 103, 83, 111, 99, 115, 67, 112, 50, 50, 87, 87, 102, 90, 119, 120, 120, 119, 82, 72, 106, 103, 112, 48, 61, 13, 10, 100, 97, 116, 101, 58, 87, 101, 100, 44, 32, 57, 32, 79, 99, 116, 32, 50, 48, 50, 52, 32, 49, 50, 58, 51, 51, 58, 51, 48, 32, 43, 48, 48, 48, 48, 32, 40, 85, 84, 67, 41, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 70, 57, 53, 50, 67, 70, 49, 65, 45, 54, 48, 51, 51, 45, 52, 53, 53, 66, 45, 65, 50, 56, 67, 45, 69, 53, 51, 53, 65, 70, 70, 65, 68, 48, 48, 68, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 62, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 109, 117, 108, 116, 105, 112, 97, 114, 116, 47, 97, 108, 116, 101, 114, 110, 97, 116, 105, 118, 101, 59, 32, 98, 111, 117, 110, 100, 97, 114, 121, 61, 65, 112, 112, 108, 101, 45, 87, 101, 98, 109, 97, 105, 108, 45, 52, 50, 45, 45, 98, 97, 56, 56, 54, 100, 51, 51, 45, 50, 98, 99, 56, 45, 52, 97, 102, 52, 45, 57, 99, 51, 49, 45, 54, 99, 52, 56, 101, 49, 51, 54, 101, 99, 50, 102, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 55, 50, 56, 52, 55, 55, 50, 49, 51, 59, 32, 98, 104, 61, 105, 116, 84, 86, 66, 71, 57, 67, 49, 52, 90, 85, 47, 43, 97, 51, 72, 68, 69, 77, 90, 114, 71, 79, 52, 118, 73, 79, 48, 80, 99, 87, 110, 81, 72, 106, 77, 101, 100, 107, 108, 67, 69, 61, 59, 32, 104, 61, 84, 111, 58, 70, 114, 111, 109, 58, 83, 117, 98, 106, 101, 99, 116, 58, 68, 97, 116, 101, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 73, 77, 69, 45, 86, 101, 114, 115, 105, 111, 110, 59, 32, 98, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        len: 530
    };
    let to_seq = Sequence {
        index: 0,
        length: 13
    };
    let email_seq = Sequence {
        index: 3,
        length: 10
    };

    check_to_field(header, padded_relayer, to_seq, email_seq);
}

#[test]
fn test_check_from_field() {
    let member = "swoons.00rubbing@icloud.com".as_bytes();
    let mut padded_member: [u8; MAX_EMAIL_ADDRESS_LENGTH] = [0; MAX_EMAIL_ADDRESS_LENGTH];
    for i in 0..member.len() {
        padded_member[i] = member[i];
    }
    for i in member.len()..MAX_EMAIL_ADDRESS_LENGTH {
        padded_member[i] = 0;
    }

    let header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH> = BoundedVec {
        storage: [116, 111, 58, 97, 100, 64, 111, 120, 111, 114, 46, 105, 111, 13, 10, 102, 114, 111, 109, 58, 115, 119, 111, 111, 110, 115, 46, 48, 48, 114, 117, 98, 98, 105, 110, 103, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 119, 70, 50, 115, 90, 68, 120, 52, 109, 99, 75, 54, 65, 115, 74, 88, 84, 74, 77, 82, 103, 83, 111, 99, 115, 67, 112, 50, 50, 87, 87, 102, 90, 119, 120, 120, 119, 82, 72, 106, 103, 112, 48, 61, 13, 10, 100, 97, 116, 101, 58, 87, 101, 100, 44, 32, 57, 32, 79, 99, 116, 32, 50, 48, 50, 52, 32, 49, 50, 58, 51, 51, 58, 51, 48, 32, 43, 48, 48, 48, 48, 32, 40, 85, 84, 67, 41, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 70, 57, 53, 50, 67, 70, 49, 65, 45, 54, 48, 51, 51, 45, 52, 53, 53, 66, 45, 65, 50, 56, 67, 45, 69, 53, 51, 53, 65, 70, 70, 65, 68, 48, 48, 68, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 62, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 109, 117, 108, 116, 105, 112, 97, 114, 116, 47, 97, 108, 116, 101, 114, 110, 97, 116, 105, 118, 101, 59, 32, 98, 111, 117, 110, 100, 97, 114, 121, 61, 65, 112, 112, 108, 101, 45, 87, 101, 98, 109, 97, 105, 108, 45, 52, 50, 45, 45, 98, 97, 56, 56, 54, 100, 51, 51, 45, 50, 98, 99, 56, 45, 52, 97, 102, 52, 45, 57, 99, 51, 49, 45, 54, 99, 52, 56, 101, 49, 51, 54, 101, 99, 50, 102, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 55, 50, 56, 52, 55, 55, 50, 49, 51, 59, 32, 98, 104, 61, 105, 116, 84, 86, 66, 71, 57, 67, 49, 52, 90, 85, 47, 43, 97, 51, 72, 68, 69, 77, 90, 114, 71, 79, 52, 118, 73, 79, 48, 80, 99, 87, 110, 81, 72, 106, 77, 101, 100, 107, 108, 67, 69, 61, 59, 32, 104, 61, 84, 111, 58, 70, 114, 111, 109, 58, 83, 117, 98, 106, 101, 99, 116, 58, 68, 97, 116, 101, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 73, 77, 69, 45, 86, 101, 114, 115, 105, 111, 110, 59, 32, 98, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        len: 530
    };
    let from_seq = Sequence {
        index: 15,
        length: 32
    };
    let email_seq = Sequence {
        index: 20,
        length: 27
    };

    check_from_field(header, padded_member, from_seq, email_seq);
}

#[test]
fn test_find_subject_in_header() {
    let subject = "wF2sZDx4mcK6AsJXTJMRgSocsCp22WWfZwxxwRHjgp0=".as_bytes();
    let mut padded_subject: [u8; MSG_HASH_LENGTH] = [0; MSG_HASH_LENGTH];
    for i in 0..subject.len() {
        padded_subject[i] = subject[i];
    }

    let header: BoundedVec<u8, MAX_EMAIL_HEADER_LENGTH> = BoundedVec {
        storage: [116, 111, 58, 97, 100, 64, 111, 120, 111, 114, 46, 105, 111, 13, 10, 102, 114, 111, 109, 58, 115, 119, 111, 111, 110, 115, 46, 48, 48, 114, 117, 98, 98, 105, 110, 103, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 13, 10, 115, 117, 98, 106, 101, 99, 116, 58, 119, 70, 50, 115, 90, 68, 120, 52, 109, 99, 75, 54, 65, 115, 74, 88, 84, 74, 77, 82, 103, 83, 111, 99, 115, 67, 112, 50, 50, 87, 87, 102, 90, 119, 120, 120, 119, 82, 72, 106, 103, 112, 48, 61, 13, 10, 100, 97, 116, 101, 58, 87, 101, 100, 44, 32, 57, 32, 79, 99, 116, 32, 50, 48, 50, 52, 32, 49, 50, 58, 51, 51, 58, 51, 48, 32, 43, 48, 48, 48, 48, 32, 40, 85, 84, 67, 41, 13, 10, 109, 101, 115, 115, 97, 103, 101, 45, 105, 100, 58, 60, 70, 57, 53, 50, 67, 70, 49, 65, 45, 54, 48, 51, 51, 45, 52, 53, 53, 66, 45, 65, 50, 56, 67, 45, 69, 53, 51, 53, 65, 70, 70, 65, 68, 48, 48, 68, 64, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 62, 13, 10, 99, 111, 110, 116, 101, 110, 116, 45, 116, 121, 112, 101, 58, 109, 117, 108, 116, 105, 112, 97, 114, 116, 47, 97, 108, 116, 101, 114, 110, 97, 116, 105, 118, 101, 59, 32, 98, 111, 117, 110, 100, 97, 114, 121, 61, 65, 112, 112, 108, 101, 45, 87, 101, 98, 109, 97, 105, 108, 45, 52, 50, 45, 45, 98, 97, 56, 56, 54, 100, 51, 51, 45, 50, 98, 99, 56, 45, 52, 97, 102, 52, 45, 57, 99, 51, 49, 45, 54, 99, 52, 56, 101, 49, 51, 54, 101, 99, 50, 102, 13, 10, 109, 105, 109, 101, 45, 118, 101, 114, 115, 105, 111, 110, 58, 49, 46, 48, 13, 10, 100, 107, 105, 109, 45, 115, 105, 103, 110, 97, 116, 117, 114, 101, 58, 118, 61, 49, 59, 32, 97, 61, 114, 115, 97, 45, 115, 104, 97, 50, 53, 54, 59, 32, 99, 61, 114, 101, 108, 97, 120, 101, 100, 47, 114, 101, 108, 97, 120, 101, 100, 59, 32, 100, 61, 105, 99, 108, 111, 117, 100, 46, 99, 111, 109, 59, 32, 115, 61, 49, 97, 49, 104, 97, 105, 59, 32, 116, 61, 49, 55, 50, 56, 52, 55, 55, 50, 49, 51, 59, 32, 98, 104, 61, 105, 116, 84, 86, 66, 71, 57, 67, 49, 52, 90, 85, 47, 43, 97, 51, 72, 68, 69, 77, 90, 114, 71, 79, 52, 118, 73, 79, 48, 80, 99, 87, 110, 81, 72, 106, 77, 101, 100, 107, 108, 67, 69, 61, 59, 32, 104, 61, 84, 111, 58, 70, 114, 111, 109, 58, 83, 117, 98, 106, 101, 99, 116, 58, 68, 97, 116, 101, 58, 77, 101, 115, 115, 97, 103, 101, 45, 73, 100, 58, 67, 111, 110, 116, 101, 110, 116, 45, 84, 121, 112, 101, 58, 77, 73, 77, 69, 45, 86, 101, 114, 115, 105, 111, 110, 59, 32, 98, 61, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        len: 530
    };

    let (found, _) = find_subject_in_header(header, padded_subject);
    assert(found);
}
